const asn1Validator = require("node-forge/lib/asn1-validator");
const assert = require("assert").strict;
const { blobFromHex, blobToHex } = require("@dfinity/candid");
const { Principal } = require("@dfinity/principal");
const crc = require("crc");
const forge = require("node-forge");
const tweetnacl = require("tweetnacl");
const { sha224 } = require("./hash");

/**
 * Instead of Buffer.from(), this doesn't do a new allocation.
 * @param {ArrayBufferView} buf
 * @returns {Buffer}
 */
function bufferFromArrayBufferView(buf) {
  return Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength);
}

/**
 * Given an account address with a prepended big-endian CRC32 checksum, verify
 * the checksum and remove it.
 * @param {Buffer} buf
 * @returns {Buffer}
 */
function crc32_del(buf) {
  const res = buf.subarray(4);
  assert(crc.crc32(res) === buf.readUInt32BE(0));
  return res;
}

/**
 * Prepend a big-endian CRC32 checksum.
 * @param {Buffer} buf
 * @returns {Buffer}
 */
function crc32_add(buf) {
  const res = Buffer.allocUnsafe(4 + buf.length);
  res.writeUInt32BE(crc.crc32(buf));
  buf.copy(res, 4);
  return res;
}

/**
 *
 * @param {Buffer?} seed
 * @returns {Buffer}
 */
function key_new(seed) {
  const { secretKey } = seed
    ? tweetnacl.sign.keyPair.fromSeed(seed)
    : tweetnacl.sign.keyPair();
  return bufferFromArrayBufferView(secretKey);
}

exports.key_new = key_new;

/**
 * Only supports PEM files generated by dfx at the moment.
 * @param {string} pem
 * @returns {Buffer}
 */
function seed_from_pem(pem) {
  const msg = forge.pem.decode(pem)[0];
  assert(msg.type === "PRIVATE KEY");
  assert(!(msg.procType && msg.procType.type === "ENCRYPTED"));
  const obj = forge.asn1.fromDer(msg.body);
  const capture = {};
  const errors = [];
  const valid = forge.asn1.validate(
    obj,
    asn1Validator.privateKeyValidator,
    capture,
    errors
  );
  assert(valid);
  const seed = Buffer.from(
    forge.asn1.fromDer(capture.privateKey).value,
    "binary"
  );
  assert(seed.byteLength === 32);
  return seed;
}

exports.seed_from_pem = seed_from_pem;

/**
 *
 * @param {Buffer} key
 * @returns {Buffer}
 */
function key_to_pub_key(key) {
  const { publicKey } = tweetnacl.sign.keyPair.fromSecretKey(key);
  return bufferFromArrayBufferView(publicKey);
}

exports.key_to_pub_key = key_to_pub_key;

/**
 *
 * @param {Buffer} key
 * @param {Buffer} msg
 * @returns {Buffer}
 */
function key_sign(key, msg) {
  return bufferFromArrayBufferView(tweetnacl.sign.detached(msg, key));
}

exports.key_sign = key_sign;

const DER_PREFIX = Buffer.from([
  0x30, 0x2a, 0x30, 0x05, 0x06, 0x03, 0x2b, 0x65, 0x70, 0x03, 0x21, 0x00,
]);

/**
 *
 * @param {Buffer} pub_key
 * @returns {Buffer}
 */
function pub_key_to_der(pub_key) {
  const buf = Buffer.allocUnsafe(DER_PREFIX.byteLength + pub_key.byteLength);
  DER_PREFIX.copy(buf, 0);
  bufferFromArrayBufferView(pub_key).copy(buf, DER_PREFIX.byteLength);
  return buf;
}

exports.pub_key_to_der = pub_key_to_der;

const SUB_ACCOUNT_ZERO = Buffer.alloc(32);
const ACCOUNT_DOMAIN_SEPERATOR = Buffer.from("\x0Aaccount-id");

/**
 *
 * @param {import("@dfinity/principal").Principal} pid
 * @returns {Buffer}
 */
function principal_id_to_address(pid) {
  return sha224([ACCOUNT_DOMAIN_SEPERATOR, pid.toUint8Array(), SUB_ACCOUNT_ZERO]);
}

exports.principal_id_to_address = principal_id_to_address;

/**
 * Given a public key, generate the account address.
 * @param {Buffer} pub_key
 * @returns {Buffer}
 */
function pub_key_to_address(pub_key) {
  return principal_id_to_address(
    Principal.selfAuthenticating(pub_key_to_der(pub_key))
  );
}

exports.pub_key_to_address = pub_key_to_address;

/**
 *
 * @param {string} hex_str
 * @returns {Buffer}
 */
function address_from_hex(hex_str) {
  assert.equal(hex_str.length, 64, "invalid input hex length");
  const buf = bufferFromArrayBufferView(blobFromHex(hex_str));
  assert.equal(buf.byteLength, 32, "invalid address length in bytes");
  const ret = crc32_del(buf);
  const hex_str2 = address_to_hex(ret);
  assert.equal(hex_str.toLowerCase(), hex_str2.toLowerCase(), "dencode/encode roundtrip changes the address");
  return ret;
}

exports.address_from_hex = address_from_hex;

/**
 *
 * @param {Buffer} addr_buf
 * @returns {string}
 */
function address_to_hex(addr_buf) {
  return blobToHex(crc32_add(addr_buf));
}

exports.address_to_hex = address_to_hex;
