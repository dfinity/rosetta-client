# ğŸš¨ Deprecated

**This repository is deprecated and is no longer maintained.**
---


# `@dfinity/rosetta-client`

[![GitHub Actions](https://github.com/dfinity/rosetta-client/workflows/integration-test/badge.svg?branch=master)](https://github.com/dfinity/rosetta-client/actions?query=branch%3Amaster)

A JavaScript package to call Rosetta API, with additional helper functions to
derive credentials and perform transfers.

ç”¨äºè°ƒç”¨ Rosetta API çš„ JavaScript åº“ï¼Œå¹¶æä¾›é«˜å±‚å‡½æ•°æ¥å£ç”¨äºç”Ÿæˆæ–°çš„ç§é’¥/è´¦æˆ·åœ°
å€ã€æ‰§è¡Œè½¬è´¦ã€‚

## Usage

### Working with ED25519 keys

```javascript
let { randomBytes } = require("crypto");
let { key_new, key_to_pub_key, seed_from_pem } = require("@dfinity/rosetta-client");

// Derive an ED25519 private key from a system random seed. The private key's
// type is Buffer.
//
// ä»ç³»ç»Ÿç”Ÿæˆçš„éšæœºç§å­ç”Ÿæˆä¸€ä¸ª ED25519 ç§é’¥ã€‚ç§é’¥ç±»å‹ä¸º Bufferã€‚
let privateKey = key_new();

// Derive an ED25519 private key from a user-specified 32-byte random seed.
//
// ä»ç”¨æˆ·æŒ‡å®šçš„ 32 å­—èŠ‚éšæœºæ•°ç§å­ç”Ÿæˆä¸€ä¸ª ED25519 ç§é’¥ã€‚
let seed = randomBytes(32);
privateKey = key_new(seed);

// You can also load the seed from the identity PEM file generated by dfx, and
// use that to generate the private key for this library. This is the preferred
// way of generating private keys, since you can also use dfx to perform
// transfers and other operations on the command line given the identity PEM
// file.
//
// æ‚¨ä¹Ÿå¯ä»¥ä» dfx ç”Ÿæˆçš„ PEM æ–‡ä»¶ä¸­è¯»å–ç§å­ï¼Œå¹¶ç”¨å…¶ç”Ÿæˆæœ¬åº“çš„ç§é’¥ã€‚æˆ‘ä»¬æ¨èä½¿ç”¨
// æœ¬æ–¹å¼ç”Ÿæˆç§é’¥ï¼Œå› ä¸º dfx å¯ä»¥è¯»å–è¯ä¹¦æ–‡ä»¶å¹¶åœ¨å‘½ä»¤è¡Œä¸‹è¿›è¡Œè½¬è´¦ç­‰æ“ä½œã€‚
seed = seed_from_pem(
  readFileSync("/home/username/.config/dfx/identity/default/identity.pem")
);
privateKey = key_new(seed);

// Use key_to_pub_key() to derive a public key from a private key. The public
// key's type is Buffer.
//
// è°ƒç”¨ key_to_pub_key() å‡½æ•°ï¼Œä»ç§é’¥ç”Ÿæˆå…¬é’¥ã€‚å…¬é’¥ç±»å‹æ˜¯ Bufferã€‚
let publicKey = key_to_pub_key(privateKey);
```

### Working with account addresses

```javascript
let {
  pub_key_to_address,
  address_from_hex,
  address_to_hex,
} = require("@dfinity/rosetta-client");

// pub_key_to_address() derives an address from a public key. The address type
// is Buffer.
//
// pub_key_to_address() å‡½æ•°ä»å…¬é’¥ç”Ÿæˆè´¦æˆ·åœ°å€ã€‚åœ°å€ç±»å‹æ˜¯Bufferã€‚
let address = pub_key_to_address(publicKey);

// address_from_hex() & address_to_hex() converts between the address Buffer and
// the hex address string used in Rosetta API requests. This is not a simple
// base16 encoding, since the hex string will also contain a CRC32 checksum.
// address_from_hex() will throw if the checksum doesn't match.
//
// address_from_hex() å’Œ address_to_hex() å‡½æ•°ç”¨äºåœ¨åœ°å€çš„ Buffer å’Œç”¨äº Rosetta
// API è¯·æ±‚ä¸­çš„åå…­è¿›åˆ¶å­—ç¬¦ä¸²ä¹‹é—´è¿›è¡Œè½¬æ¢ã€‚è½¬æ¢è¿‡ç¨‹å¹¶éç®€å•çš„ base16 ç¼–ç ï¼Œå› ä¸º
// åå…­è¿›åˆ¶å­—ç¬¦ä¸²ä¸­è¿˜ä¼šåŒ…å«ä¸€ä¸ª CRC32 æ ¡éªŒç ã€‚address_from_hex() åœ¨æ ¡éªŒç é”™è¯¯æ—¶
// ä¼šæŠ›å‡ºå¼‚å¸¸ã€‚
address = address_from_hex(address_to_hex(address));
```

### Calling Rosetta API and performing transfers

```javascript
let { Session } = require("@dfinity/rosetta-client");

// A Session implements the interface of RosettaClient as specified in
// https://www.npmjs.com/package/@lunarhq/rosetta-ts-client, and you can use
// methods of RosettaClient to invoke the Rosetta API.
//
// Session å®ç°äº† https://www.npmjs.com/package/@lunarhq/rosetta-ts-client æè¿°
// çš„ RosettaClient ç±»æ¥å£ï¼Œå¯ä»¥è°ƒç”¨ RosettaClient çš„æ–¹æ³•ä½¿ç”¨ Rosetta APIã€‚
let session = new Session({ baseUrl: "http://127.0.0.1:8080" });

// The network_identifier value used in requests.
//
// è¯·æ±‚ä¸­çš„ network_identifier ä¸€æ æ‰€ç”¨çš„å€¼ã€‚
console.log(await session.network_identifier);

// The currency value used in requests.
//
// è¯·æ±‚ä¸­çš„ currency ä¸€æ æ‰€ç”¨çš„å€¼ã€‚
console.log(await session.currency);

// A BigInt value representing the transaction fee. At the moment, despite the
// name "suggested_fee", the fee is mandatory.
//
// ä»£è¡¨äº¤æ˜“è´¹ç”¨çš„ BigInt å€¼ã€‚å°½ç®¡ Rosetta API ä¸­å°†å…¶ç§°ä¸ºâ€œå»ºè®®è´¹ç”¨â€ï¼Œè¯¥è´¹ç”¨ç›®å‰æ˜¯
// å¼ºåˆ¶çš„ã€‚
console.log(await session.suggested_fee);

// Given the source account private key as a Buffer, the destination account as
// a Buffer, the transfer amount as a BigInt, perform a transfer and return the
// result of the /construction/submit call.
//
// The destination account will receive the specified amount. An additional fee
// will be charged from the source account.
//
// ç»™å®šåˆ’å‡ºè´¦æˆ·ç§é’¥çš„ Buffer å¯¹è±¡ã€åˆ’å…¥è´¦æˆ·åœ°å€çš„ Buffer å¯¹è±¡å’Œåˆ’è½¬é‡‘é¢çš„ BigInt
// å€¼ï¼Œå‘èµ·ä¸€æ¬¡è½¬è´¦ï¼Œå¹¶è¿”å› /construction/submit è°ƒç”¨çš„ç»“æœã€‚
//
// åˆ’å…¥è´¦æˆ·å°†æ”¶åˆ°æŒ‡å®šé‡‘é¢ï¼Œåˆ’å‡ºè´¦æˆ·åˆ™å°†é¢å¤–æ‰£é™¤äº¤æ˜“è´¹ç”¨ã€‚
let submit_result = await session.transfer(src_private_key, dest_addr, 123n);
console.log(submit_result);
```

### Querying a transaction given a transaction hash

```javascript
// Call the /search/transactions endpoint and search for an on-chain transaction
// given its hash. Other query conditions of /search/transactions are not
// implemented yet.
//
// è°ƒç”¨ /search/transactions æ¥å£ï¼Œé€šè¿‡äº‹åŠ¡ hash å€¼æ£€ç´¢å…¶æ˜¯å¦ä¸Šé“¾ã€‚
// /search/transactions æ¥å£çš„å…¶ä»–æ£€ç´¢æ¡ä»¶ç›®å‰æš‚æœªå®ç°ã€‚
let transactions_result = await session.transactions({
  network_identifier: await session.network_identifier,
  transaction_identifier: submit_result.transaction_identifier,
});

console.log(transactions_result.transactions[0]);
```

### Performing transfers while keeping the private keys in an isolated environment

```javascript
let { transfer_combine } = require("@dfinity/rosetta-client");

// Due to security concerns, you may wish to avoid calling transfer() which
// consumes the private key and performs network calls. We support using the
// private key only in a fully isolated environment while performing a transfer,
// here's an example.
//
// å‡ºäºå®‰å…¨è€ƒè™‘ï¼Œæ‚¨ä¹Ÿè®¸å¸Œæœ›é¿å…è°ƒç”¨ transfer() æ–¹æ³•ï¼Œå› ä¸ºå®ƒéœ€è¦ä¼ å…¥ç§é’¥å‚æ•°ï¼Œå¹¶
// ä¸”ä¼šæ‰§è¡Œç½‘ç»œè°ƒç”¨ã€‚æˆ‘ä»¬æ”¯æŒåœ¨è½¬è´¦æ—¶ï¼Œä»…åœ¨å®Œå…¨éš”ç¦»çš„ç¯å¢ƒä¸­ä½¿ç”¨ç§é’¥ï¼Œç”¨ä¾‹å¦‚ä¸‹ã€‚
let payloads_result = await session.transfer_pre_combine(
  src_public_key,
  dest_addr,
  123n
);

// This step can be executed in a fully isolated environment. The result is the
// same of calling /construction/combine with session.combine().
//
// è¯¥æ­¥éª¤å¯åœ¨å®Œå…¨éš”ç¦»çš„ç¯å¢ƒä¸­æ‰§è¡Œã€‚ä¸é€šè¿‡ session.combine() è°ƒç”¨ /construction/combine çš„ç»“æœç›¸åŒã€‚
let combine_result = transfer_combine(src_private_key, payloads_result);

submit_result = await session.transfer_post_combine(combine_result);
```

### Submitting a transaction in a configurable time period

```javascript
// The transfer()/transfer_pre_combine() functions take two extra optional
// parameters. One is max_fee, another is an object for additional metadata in
// the /construction/payloads request.
//
// It's possible to specify ingress_start/ingress_end in the metadata, so that
// you can generate and sign a transaction earlier, but postpone the submission
// later. The submission period must be within the next 24 hours.
// ingress_start/ingress_end are BigInt values specifying nanoseconds since unix
// epoch, and you can specify only single one of it.
//
// transfer()/transfer_pre_combine() å‡½æ•°è¿˜æœ‰ä¸¤ä¸ªå¯é€‰å‚æ•°ï¼Œä¸€ä¸ªæ˜¯ max_feeï¼Œå¦ä¸€
// ä¸ªæ˜¯ä½œä¸º /construction/payloads è¯·æ±‚çš„é¢å¤– metadata çš„å¯¹è±¡ã€‚
//
// å¯ä»¥åœ¨ metadata ä¸­æŒ‡å®š ingress_start/ingress_endï¼Œä»è€Œæå‰ç”Ÿæˆå¹¶ç­¾åä¸€æ¡äº‹
// åŠ¡ï¼Œä½†å°†äº‹åŠ¡çš„æäº¤æ¨è¿Ÿåˆ°ä¹‹åçš„æ—¶é—´ã€‚æäº¤æ—¶é—´å¿…é¡»ä¸æ™šäºäº‹åŠ¡ç”Ÿæˆåçš„ 24 å°æ—¶ã€‚
// ingress_start/ingress_end æ˜¯çº³ç§’å•ä½ Unix æ—¶é—´æˆ³çš„ BigInt å€¼ï¼Œå¯ä»¥å…¨éƒ¨æŒ‡å®šä¹Ÿ
// å¯ä»¥åªæŒ‡å®šä¸€ä¸ªã€‚

payloads_result = await session.transfer_pre_combine(
  src_public_key,
  dest_addr,
  123n,
  undefined,
  { ingress_start, ingress_end }
);
```

### Decoding a signed transaction

```javascript
const { signed_transaction_decode } = require("@dfinity/rosetta-client");

// You may wish to decode a signed transaction and verify the content before
// actually submitting it. Here's how.
//
// æ‚¨ä¹Ÿè®¸æƒ³è¦åœ¨æäº¤å·²ç­¾åçš„äº‹åŠ¡å‰ï¼Œå…ˆå°†å…¶ååºåˆ—åŒ–å¹¶æ ¡éªŒå…¶å†…å®¹ã€‚ç¤ºä¾‹å¦‚ä¸‹ã€‚

// The signed_transaction field is a hex-encoded string. Pass it directly to
// signed_transaction_decode().
//
// signed_transaction æ˜¯åå…­è¿›åˆ¶ç¼–ç çš„å­—ç¬¦ä¸²ã€‚ç›´æ¥å°†å…¶ä¼ ç»™
// signed_transaction_decode() å³å¯ã€‚
const tx = signed_transaction_decode(combine_result.signed_transaction);

// The source account as a Buffer.
//
// è½¬å‡ºè´¦æˆ·çš„ Buffer å€¼ã€‚
console.log(address_to_hex(tx.from));

// The destination account as a Buffer.
//
// è½¬å…¥è´¦æˆ·çš„ Buffer å€¼ã€‚
console.log(address_to_hex(tx.to));

// The transfer amount as a BigInt.
//
// è½¬è´¦é‡‘é¢çš„ BigInt å€¼ã€‚
console.log(tx.amount);

// The additional transaction fee as a BigInt.
//
// é¢å¤–çš„äº¤æ˜“è´¹ç”¨çš„ BigInt å€¼ã€‚
console.log(tx.fee);

// The source account's public key as a Buffer.
//
// è½¬å‡ºè´¦æˆ·å…¬é’¥çš„ Buffer å€¼ã€‚
console.log(tx.sender_pubkey);
```

### Staking

See [neuron
lifecycle](https://github.com/dfinity/ic/blob/master/rs/rosetta-api/docs/modules/rosetta-api/pages/neuron-lifecycle.adoc)
and [staking
support](https://github.com/dfinity/ic/blob/master/rs/rosetta-api/docs/modules/rosetta-api/pages/staking-support.adoc)
for more information about staking.

```javascript
// The main way to identify a neuron is the combination of
// controller+index. Here, we assume `src_key` is the controller's
// private key, `neuron_idx` is the neuron index, a 64-bit BigInt.
//
// Neuron index values need to be unique within the same controller's
// scope, but may overlap for different controllers.
const neuron_idx = 1919810n;

// Perform a transfer to top-up the neuron. The minimum amount is 1ICP
// for staking.
await session.neuron_charge(src_key, neuron_idx, 100000000n);

// Then do a STAKE operation, which notifies the governance canister
// and starts the neuron's lifecycle.
await session.neuron_stake(src_key, neuron_idx);

// Set the neuron's dissolve timestamp. The unit is seconds since unix
// epoch.
await session.neuron_set_dissolve_timestamp(
  src_key,
  neuron_idx,
  seconds_since_unix_epoch() + 86400n
);

// Start dissolving the neuron.
await session.neuron_start_dissolving(src_key, neuron_idx);

// Stop dissolving the neuron.
await session.neuron_stop_dissolving(src_key, neuron_idx);

// Disburse the neuron. Transfer some of the staked ICPs to a ledger
// address. dest_addr is optional, and defaults to controller's
// address; amount is optional, defaults to all staked ICPs.
await session.neuron_disburse(src_key, neuron_idx, dest_addr, 1n);

// Merge the neuron's maturity, increasing its stake. The percentage
// needs to be an integer between 1 and 100, defaults to 100 when
// absent.
await session.neuron_merge(src_key, neuron_idx, 50);

// Spawn the neuron's maturity to another new neuron's staked amount.
// The spawned neuron's controller public key is optional, and
// defaults to the original controller.
await session.neuron_spawn(
  src_key,
  neuron_idx,
  spawned_neuron_pub_key,
  spawned_neuron_idx
);

// Add a hot key for a neuron. Hot keys can be used instead of the
// controller's private key for a few operations. We assume hot_key is
// the hot key's private key, and hot_pub_key is the derived public
// key.
await session.neuron_add_hotkey(src_key, neuron_idx, hot_pub_key);

// Remove a previously added hot key.
await session.neuron_remove_hotkey(src_key, neuron_idx, hot_pub_key);

// Get a neuron's public info. This only requires the controller's
// public key.
await session.neuron_public_info(src_pub_key, neuron_idx);

// Get a neuron's protected info. This can be done with a hot key;
// when src_pub_key is not present, we assume there's no hot key
// involved and the first argument is the controller's private key.
await session.neuron_protected_info(hot_key, neuron_idx, src_pub_key);

// Make a neuron follow other neurons to automatically vote on a
// certain topic. Likewise, can be done with a hot key optionally. See
// the staking support documentation about the semantics of followees
// and topic.
await session.neuron_follow(hot_key, neuron_idx, src_pub_key, followees, topic);
```

### Creating & using a JS bundle

You can bundle this package and its dependencies into a single JS file, and use
it as a regular CommonJS module.

æ‚¨å¯ä»¥å°†æœ¬åº“åŠå…¶ä¾èµ–åº“æ‰“åŒ…æˆå•ä¸ª JS æ–‡ä»¶ï¼Œåƒæ™®é€šçš„ CommonJS æ¨¡å—ä¸€æ ·ä½¿ç”¨å®ƒã€‚

```sh
$ npm install
$ npm run-script build
$ node --eval "console.log(require('./dist/main.js'))"
```

The bundled JS file is also available as the `dist` artifact on CI.

æ‰“åŒ…å¥½çš„ JS æ–‡ä»¶ä¹Ÿå¯ä» CI ä¸Šç”Ÿæˆçš„ `dist` æ–‡ä»¶ç›´æ¥ä¸‹è½½ã€‚

## Supported Node.js versions

This package is tested against latest versions of Node.js v12/v14/v16/v17.

## Common traps and pitfalls

### Working with BigInt

Because of JavaScript number type's [limit][js-max-safe-int] in integer
precision, we use `BigInt`s everywhere (amounts, fee, timestamps, etc) to
represent integers. There are things to watch out when using `BigInt`s with this
package:

ç”±äº JavaScript æ•°å­—ç±»å‹è¡¨ç¤ºæ•´æ•°æ—¶çš„ç²¾åº¦[é™åˆ¶][js-max-safe-int]ï¼Œæˆ‘ä»¬åœ¨æœ¬åº“ä¸­å‡¡
æ˜¯æ¶‰åŠæ•´æ•°çš„éƒ¨åˆ†å‡ä½¿ç”¨ `BigInt` ç±»å‹ï¼ˆå¦‚è½¬è´¦é‡‘é¢ã€äº¤æ˜“è´¹ç”¨ã€æ—¶é—´æˆ³ç­‰ï¼‰ã€‚ä½¿ç”¨
`BigInt` æ—¶éœ€è¦ç•™æ„çš„è¦ç‚¹ï¼š

```javascript
// Don't do this! Precision loss!
// ä¸è¦è¿™æ ·ï¼Œä¼šæœ‰ç²¾åº¦æŸå¤±ï¼
let timestamp = BigInt(Date.now() * 1000000);

// Do this instead!
// è¿™æ ·æ‰å¯¹ï¼
let timestamp = BigInt(Date.now()) * 1000000n;
```

Also, JavaScript's builtin `JSON` encoder/decoder won't work with the
input/output data of this package. We use [`json-bigint`][json-bigint] for JSON
encoding/decoding in this package, and if you need to work with JSON too, you
also need `json-bigint`.

å¦å¤–ï¼ŒJavaScript å†…ç½®çš„ `JSON` åºåˆ—åŒ–å‡½æ•°ä¸èƒ½ç”¨äºæœ¬åº“è¾“å…¥/è¾“å‡ºçš„æ•°æ®ã€‚æˆ‘ä»¬ä½¿ç”¨
[`json-bigint`][json-bigint] åº“ç”¨äº JSON åºåˆ—åŒ–ï¼Œå¦‚æœæ‚¨ä¹Ÿéœ€è¦å¤„ç† JSON æ•°æ®ï¼Œæ‚¨
ä¹Ÿåº”å½“ä½¿ç”¨ `json-bigint`.

```javascript
const JSONbig = require("json-bigint")({ strict: true, useNativeBigInt: true });
JSONbig.parse(); // Use this instead of JSON.parse()
JSONbig.stringify(); // Use this instead of JSON.stringify()
```

[json-bigint]: https://www.npmjs.com/package/json-bigint
[js-max-safe-int]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/MAX_SAFE_INTEGER
[rosetta-ts-client]: https://github.com/lunarhq/rosetta-ts-client

<!--
## TODO

- [x] Watch out for the next test net deployment, set appropriate default fee.
- [x] Given a transaction hash, query the transfer status and confirm if it
      reached the chain or is rejected. Since `ic-rosetta-api` doesn't implement
      [`/search/transactions`][search_transactions] yet, the JavaScript SDK may need
      to workaround this by polling all blocks and doing its own indexing.
- [ ] Error handling in the polling logic.
- [ ] Other high-level Rosetta API wrappers (or redirect underlying
  `RosettaClient` method calls so to avoid some boilerplates in the request,
  e.g. `network_identifier`).
- [x] Proper license & packaging.
- [ ] Better names.

[search_transactions]: https://www.rosetta-api.org/docs/SearchApi.html#searchtransactions
-->
